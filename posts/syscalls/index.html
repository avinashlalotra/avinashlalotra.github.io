
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Linux Syscalls</title>
<style>
  body {
    font-family: "Inter", system-ui, sans-serif;
    background-color: hsl(var(--background));
    color: hsl(var(--foreground));
    margin: 0;
    padding: 0;
    line-height: 1.7;
    transition: background-color 0.3s, color 0.3s;
  }

  article {
    max-width: 800px;
    margin: 2rem auto;
    padding: 2rem;
    background-color: hsl(var(--card));
    color: hsl(var(--card-foreground));
    border-radius: var(--radius);
    box-shadow: 0 2px 12px hsl(var(--border) / 0.3);
    transition: background-color 0.3s, color 0.3s, box-shadow 0.3s;
  }

  h1, h2, h3 {
    line-height: 1.3;
    font-weight: 600;
  }
  h1 { font-size: 2rem; margin-bottom: 0.5rem; }
  h2 {
    margin-top: 2rem;
    font-size: 1.5rem;
    border-bottom: 1px solid hsl(var(--border));
    padding-bottom: 0.3rem;
  }

  pre {
    background-color: hsl(var(--code-bg));
    color: hsl(var(--code-text));
    padding: 1rem 1.2rem;
    border-radius: 10px;
    overflow-x: auto;
    font-family: "Fira Code", monospace;
    font-size: 0.95rem;
    margin: 1.5rem 0;
    transition: background-color 0.3s, color 0.3s;
  }

  code {
    background-color: hsl(var(--code-bg));
    color: hsl(var(--code-text));
    padding: 0.2em 0.4em;
    border-radius: 4px;
    font-family: "Fira Code", monospace;
    font-size: 0.95em;
    transition: background-color 0.3s, color 0.3s;
  }

  pre code {
    background: none;
    padding: 0;
  }

  a {
    color: hsl(var(--primary));
    text-decoration: none;
    transition: color 0.3s;
  }

  a:hover {
    text-decoration: underline;
  }

  hr {
    border: none;
    border-top: 1px solid hsl(var(--border));
    margin: 2rem 0;
  }

  p, ul, ol {
    margin-bottom: 1rem;
  }

  ul {
    padding-left: 1.5rem;
  }

  i {
    color: hsl(var(--muted-foreground));
  }

  h1 code, h2 code, h3 code {
    background-color: hsl(var(--muted));
    color: hsl(var(--foreground));
    padding: 0.15em 0.3em;
    border-radius: 4px;
    font-size: 0.9em;
  }
</style>

<script>
  window.location.replace(window.location.origin + '/?redirect=' + window.location.pathname);
</script>




</head>
<body>
  <article>
    <h1>Linux Syscalls</h1>
    <p><i>2025-11-01 ‚Äî Abinash</i></p>
    <h1>Introduction to System Calls</h1>
<p>The kernel is the core part of an operating system. It acts as a bridge between software applications and computer hardware.</p>
<img src="images/syscalls/kernel.webp">

<p>The kernel manages system resources such as the CPU, memory, and devices, ensuring that everything works together efficiently.<br>It handles essential tasks like running programs, accessing files, and communicating with devices such as printers and keyboards.</p>
<p>System calls are the mechanism used to interact with the kernel. They are the only way for user-space programs to use kernel functionality.</p>
<p>System calls form a layer between hardware and user-space processes. This layer serves three main purposes:</p>
<ol>
<li>Provides an abstract hardware interface for user-space  </li>
<li>Ensures system security and stability  </li>
<li>Acts as a single, consistent interface between user-space and the kernel</li>
</ol>
<p>Let‚Äôs take the classical ‚ÄúHello World‚Äù program, probably the first one you ever executed:</p>
<pre><code class="language-c">printf(&quot;Hello, World!&quot;);
</code></pre>
<p>Internally, this <code>printf()</code> function calls <code>print()</code> from the C library, which in turn calls <code>write()</code> from the same library, and finally invokes the <code>write()</code> system call.</p>
<img src="images/syscalls/printftokernel.png">

<p><code>write()</code> is a system call. Linux on x86_64 provides around 400+ system calls.<br>Each one serves a unique purpose‚Äîsome only read kernel state, while others modify it.</p>
<h2>Syscalls</h2>
<p>System calls (syscalls) are usually accessed through functions defined in the C library.<br>They can accept zero or more arguments and always return a value of type <code>long</code>.</p>
<p>A return value of <code>0</code> indicates success, while a negative value represents an error.<br>For instance, <code>-ENOSYS</code> is returned if the syscall is not implemented.</p>
<p>The return value also sets the global variable <code>errno</code>, which can be converted to human-readable messages using <code>perror()</code>.</p>
<h2>System Call Numbers</h2>
<p>In Linux, each system call is assigned a unique syscall number. This number is used to reference the system call internally‚Äîthe process never refers to the syscall by name.</p>
<p>Changing syscall numbers can break existing applications because they rely on these fixed identifiers.</p>
<p>The kernel maintains all registered system calls in a system call table named <code>sys_call_table</code>.</p>
<p>This table is architecture-specific. On x86-64 systems, it is defined in:<br><code>arch/x86/entry/syscalls/syscall_64.tbl</code></p>
<p>This table maps each system call to its number.</p>
<h2>System Call Handler</h2>
<p>User-space applications cannot directly execute kernel code. They cannot simply call kernel functions because the kernel resides in a protected memory space.</p>
<p>Instead, user-space programs must request the kernel to execute a system call. This triggers a mode switch from user-space to kernel-space, where the system call is executed by the kernel on behalf of the application.</p>
<p>On early 32-bit systems, this was done using software interrupts. The interrupt <code>int $0x80</code> (128) was assigned as the system call handler.</p>
<img src="images/syscalls/syshandler.png">

<p>The system call handler executes the requested call. However, this interrupt mechanism was relatively slow, so modern x86 processors introduced <code>syscall</code> and <code>sysenter</code> instructions, which are much faster.</p>
<h2>Parameter Passing</h2>
<p>Most syscalls require one or more parameters in addition to the syscall number.<br>User-space programs must pass these parameters to the kernel during the trap.</p>
<p>On x86-32, parameters are passed via registers: <code>ebx</code>, <code>ecx</code>, <code>edx</code>, <code>esi</code>, and <code>edi</code> hold the first five arguments in order.<br>If there are six or more, a pointer to user-space memory containing the remaining parameters is passed in a register.</p>
<p>The return value is also returned to user-space via a register‚Äîon x86, it‚Äôs stored in <code>eax</code>.</p>
<h1>System Call Implementation</h1>
<p>Now that we understand the basics, let‚Äôs implement a custom system call.</p>
<h2>Get the Kernel Source</h2>
<pre><code class="language-bash">git clone https://github.com/torvalds/linux.git --depth=1
</code></pre>
<p>First, decide the purpose of the new system call.<br>Here, we‚Äôll implement a simple one that returns the PID of the process calling it.</p>
<p>Since no additional information is required, this syscall takes no arguments.</p>
<p>The Linux kernel provides macros to simplify syscall definition.<br>While you can define a syscall manually, using macros is cleaner and less error-prone.</p>
<p>Create a new file under <code>arch/x86/kernel/</code> named <code>mysyscall.c</code>:</p>
<pre><code class="language-c">#include &lt;linux/kernel.h&gt;
#include &lt;linux/syscalls.h&gt;
#include &lt;asm/current.h&gt;

SYSCALL_DEFINE0(my_pid) {
    return task_tgid_vnr(current); // Returns the PID of the current process
}
</code></pre>
<p>That‚Äôs it.<br><code>SYSCALL_DEFINE($num_of_arguments)(syscall_name) { implementation }</code><br>expands internally to:</p>
<pre><code class="language-c">asmlinkage long sys_my_pid(void) {
    return task_tgid_vnr(current);
}
</code></pre>
<p>Syscalls return a <code>long</code> value.</p>
<p>Next, register the new syscall by adding it to the syscall table:<br><code>arch/x86/entry/syscalls/syscall_64.tbl</code></p>
<p>Assign an unused number, for example, <code>470</code>:</p>
<pre><code>Number   Type    User-space Name   Kernel-space Name
467      common  open_tree_attr    sys_open_tree_attr
468      common  file_getattr      sys_file_getattr
469      common  file_setattr      sys_file_setattr
470      common  my_pid            sys_my_pid
</code></pre>
<p>In kernel space, our function name is <code>sys_my_pid</code>, and in user space, it‚Äôs <code>my_pid</code>.</p>
<p>Now link the new file with the kernel. Edit <code>arch/x86/kernel/Makefile</code>:</p>
<pre><code class="language-Makefile">obj-y += mysyscall.o
</code></pre>
<p>Compile and boot the kernel:</p>
<pre><code class="language-bash">cp /boot/config-$(uname -r) .config
make oldconfig
make -j$(nproc)
sudo make modules_install
sudo make install
sudo update-grub
</code></pre>
<h2>Reboot</h2>
<pre><code class="language-bash">sudo reboot
</code></pre>
<p>After booting into the new kernel‚Äîcongratulations, your syscall is ready.</p>
<h1>Next Steps: Calling from User Space</h1>
<p>There are two ways to call this new system call from user space:</p>
<ol>
<li>Using libc** ‚Äî via <code>syscall(syscall_number)</code>  </li>
<li>Using custom assembly** ‚Äî via <code>int $0x80</code> or <code>syscall</code> instruction</li>
</ol>
<p>Let‚Äôs implement both methods.</p>
<p>Create a directory for experiments:</p>
<pre><code class="language-bash">cd ~
mkdir experiments
</code></pre>
<p>Create a header file <code>my_pid.h</code>:</p>
<pre><code class="language-c">#define __NR_my_pid 470
long my_pid_int(void);
long my_pid_syscall(void);
</code></pre>
<p>Now create an assembly file <code>my_pid.S</code>:</p>
<pre><code>.text
.global my_pid_int, my_pid_syscall
.type my_pid_int, @function
.type my_pid_syscall, @function
.equ __NR_my_pid, 470

my_pid_int:
    mov $__NR_my_pid, %eax
    int $0x80
    ret

my_pid_syscall:
    mov $__NR_my_pid, %rax
    syscall
    ret
</code></pre>
<p>Then create <code>main.c</code>:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;sys/syscall.h&gt;
#include &quot;my_pid.h&quot;

int main() {
    printf(&quot;The PID (using interrupt): %ld\n&quot;, my_pid_int());
    printf(&quot;The PID (using syscall): %ld\n&quot;, my_pid_syscall());
    printf(&quot;The PID (using libc): %ld\n&quot;, syscall(__NR_my_pid));
    return 0;
}
</code></pre>
<p>Compile and run:</p>
<pre><code class="language-bash">gcc my_pid.S main.c -o mypid
./mypid
</code></pre>
<p>If you get a negative PID, it means the syscall was not properly mapped or you booted the wrong kernel.<br>Reboot into the kernel where you added the syscall.</p>
<h2>Issues ??</h2>
<p>If you are facing some issues kindly visit <a href="https://github.com/avinashlalotra/Syscalls">https://github.com/avinashlalotra/Syscalls</a> and follow the instructions</p>
<p>Thanks for reading!<br>‚Äî Abinash Singh üìå GitHub: <a href="https://github.com/avinashlalotra/Syscalls">https://github.com/avinashlalotra/Syscalls</a></p>

  </article>
</body>
</html>
  