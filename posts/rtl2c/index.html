<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RTL2C</title>
<style>
  :root { --max-content: 1100px; }
  body {
    font-family: "Inter", system-ui, sans-serif;
    background-color: hsl(var(--background));
    color: hsl(var(--foreground));
    margin: 0;
    padding: 0;
    line-height: 1.7;
    transition: background-color 0.3s, color 0.3s;
  }

  .post-page {
    display: grid;
    grid-template-columns: 260px 1fr;
    gap: 2rem;
    max-width: calc(var(--max-content) + 320px);
    margin: 1.5rem auto;
    padding: 1rem;
    align-items: start;
  }

  @media (max-width: 1024px) {
    .post-page { grid-template-columns: 1fr; padding: 1rem; }
    .post-toc { display: none; }
  }

  .post-toc {
    position: sticky;
    top: 1.5rem;
    align-self: start;
    padding: 1rem;
    border-radius: 8px;
    background-color: hsl(var(--card));
    box-shadow: 0 6px 24px hsl(var(--border) / 0.06);
    max-height: calc(100vh - 3rem);
    overflow: auto;
  }

  .post-main {
    width: 100%;
  }

  article {
    max-width: var(--max-content);
    margin: 0;
    padding: 2rem;
    background-color: transparent;
    color: hsl(var(--card-foreground));
    border-radius: var(--radius);
    transition: background-color 0.3s, color 0.3s, box-shadow 0.3s;
  }

  h1, h2, h3 {
    line-height: 1.3;
    font-weight: 600;
  }
  h1 { font-size: 2rem; margin-bottom: 0.5rem; }
  h2 {
    margin-top: 2rem;
    font-size: 1.5rem;
    border-bottom: 1px solid hsl(var(--border));
    padding-bottom: 0.3rem;
  }

  pre {
    background-color: hsl(var(--code-bg));
    color: hsl(var(--code-text));
    padding: 1rem 1.2rem;
    border-radius: 10px;
    overflow-x: auto;
    font-family: "Fira Code", monospace;
    font-size: 0.95rem;
    margin: 1.5rem 0;
    transition: background-color 0.3s, color 0.3s;
  }

  code { background-color: hsl(var(--code-bg)); color: hsl(var(--code-text)); padding: 0.2em 0.4em; border-radius: 4px; }

  a { color: hsl(var(--primary)); text-decoration: none; }
  a:hover { text-decoration: underline; }

  hr { border: none; border-top: 1px solid hsl(var(--border)); margin: 2rem 0; }

  p, ul, ol { margin-bottom: 1rem; }
  ul { padding-left: 1.5rem; }

  .toc-list { list-style: none; padding: 0; margin: 0; }
  .toc-list li { margin: 0.25rem 0; }
  .toc-list a { color: hsl(var(--muted-foreground)); font-size: 0.95rem; }
  .toc-list a.active { color: hsl(var(--primary)); font-weight: 600; }

  h1 code, h2 code, h3 code { background-color: hsl(var(--muted)); color: hsl(var(--foreground)); padding: 0.15em 0.3em; border-radius: 4px; font-size: 0.9em; }
</style>

<script>
  window.location.replace(window.location.origin + '/?redirect=' + window.location.pathname);
</script>

</head>
<body>
  <div class="post-page">
    <aside id="post-toc" class="post-toc">
      <!-- TOC will be populated by the client -->
      <div><strong>On this page</strong></div>
      <ul class="toc-list"></ul>
    </aside>
    <div class="post-main">
      <article>
        <h1>RTL2C</h1>
        <p><i>2025-11-01 ‚Äî Abinash</i></p>
        <h2>üöÄ Hello World from Scratch: Bringing Up a RISC-V Core from RTL to C</h2>
<p>Welcome! If you&#39;re wondering how to get started with hardware design, you&#39;ve landed in the right place.</p>
<p>This guide takes you from zero to running C programs on an FPGA, using an open-source RISC-V core. Whether you&#39;re a student, hobbyist, or engineer looking to understand the full hardware-software bring-up process, this post will walk you through the essentials ‚Äî from writing Verilog to printing &quot;Hello, World&quot; on your console.</p>
<h1>üéØ Goals</h1>
<ul>
<li><p>Boot an FPGA with a CPU and memory</p>
</li>
<li><p>Add peripherals like UART, GPIO, LEDs, or your own custom digital logic</p>
</li>
<li><p>Run C and assembly programs on the system</p>
</li>
<li><p>Finally... print &quot;Hello, World&quot; to the console!</p>
</li>
</ul>
<h1>üß∞ Requirements</h1>
<ul>
<li><p>Any FPGA board</p>
</li>
<li><p>A system with Vivado installed</p>
</li>
<li><p>Basic familiarity with Verilog, C, and assembly (If you&#39;re new to these ‚Äî no worries! This guide is beginner-friendly.)</p>
</li>
</ul>
<p>Preferably a Linux system (Windows can work too, with some extra setup)</p>
<h1>üõ†Ô∏è Steps Overview</h1>
<ul>
<li><p><a href="#step1">Set up the PicoRV32 core</a></p>
</li>
<li><p><a href="#step2">Connect peripherals</a></p>
</li>
<li><p>Install the RISC-V toolchain (riscv-gcc, etc.)</p>
</li>
<li><p>Write, compile, and load C programs into memory</p>
</li>
<li><p>Watch your console light up with:</p>
</li>
</ul>
<pre><code class="language-bash">Hello, World
</code></pre>
<h2>üß™ <a id="step1"></a>Step 1: Set Up the PicoRV32 Core</h2>
<p>We&#39;ll be using the open-source PicoRV32 core, which implements the RV32IMC instruction set ‚Äî meaning it supports 32-bit integer operations, multiplication, and compressed instructions. It doesn&#39;t support floating point operations, which is fine for our minimal setup.</p>
<p>üîß Clone the repository:</p>
<pre><code class="language-bash">git clone https://github.com/YosysHQ/picorv32.git
</code></pre>
<p>üõ† Add PicoRV32 to Your Vivado Project
Open Vivado and create a new project.</p>
<p>Add picorv32.v to your design sources.</p>
<p>Modify picorv32.v as follows:</p>
<p>Find this block:</p>
<pre><code class="language-verilog">// `define PICORV32_REGS picorv32_regs
</code></pre>
<p>Uncomment the line so it becomes:</p>
<pre><code class="language-verilog">`define PICORV32_REGS picorv32_regs
This enables using the register file in a separate module.
</code></pre>
<p>üß† Add Memory Module (memory.v)
Create a new Verilog file called memory.v with the following content:</p>
<pre><code class="language-verilog">module memory #(
    parameter integer WORDS = 256
) (
    input clk,
    input [3:0] wen,
    input [21:0] addr,
    input [31:0] wdata,
    output reg [31:0] rdata
);
    reg [31:0] mem [0:WORDS-1];

    initial begin
        $readmemh(&quot;memory.mem&quot;, mem);
    end

    always @(posedge clk) begin
        rdata &lt;= mem[addr];
        if (wen[0]) mem[addr][ 7: 0] &lt;= wdata[ 7: 0];
        if (wen[1]) mem[addr][15: 8] &lt;= wdata[15: 8];
        if (wen[2]) mem[addr][23:16] &lt;= wdata[23:16];
        if (wen[3]) mem[addr][31:24] &lt;= wdata[31:24];
    end
endmodule
</code></pre>
<p>Each word is 4 bytes (32 bits).</p>
<p>Memory is initialized from a file called memory.mem, which will be generated by the compiler later.</p>
<p>üß± Create Top-Level Module (top.v)
This module connects the CPU and memory using PicoRV32‚Äôs native memory interface:</p>
<pre><code class="language-verilog">module top (
    input clk,
    input resetn
);
    parameter [0:0] BARREL_SHIFTER = 1;
    parameter [0:0] ENABLE_MUL = 1;
    parameter [0:0] ENABLE_DIV = 1;
    parameter [0:0] ENABLE_FAST_MUL = 0;
    parameter [0:0] ENABLE_COMPRESSED = 1;
    parameter [0:0] ENABLE_COUNTERS = 1;
    parameter [0:0] ENABLE_IRQ_QREGS = 0;

    parameter integer MEM_WORDS = 256;
    parameter [31:0] STACKADDR = (4 * MEM_WORDS);
    parameter [31:0] PROGADDR_RESET = 32&#39;h0010_0000;
    parameter [31:0] PROGADDR_IRQ = 32&#39;h0000_0000;

    wire mem_valid, mem_instr, mem_ready;
    wire [31:0] mem_addr, mem_wdata, mem_rdata;
    wire [3:0] mem_wstrb;

    reg mem_ready_reg;
    assign mem_ready = mem_ready_reg;

    always @(posedge clk) begin
        mem_ready_reg &lt;= mem_valid;  // 1 cycle delayed
    end

    picorv32 #(
        .STACKADDR(STACKADDR),
        .PROGADDR_RESET(PROGADDR_RESET),
        .PROGADDR_IRQ(PROGADDR_IRQ),
        .BARREL_SHIFTER(BARREL_SHIFTER),
        .COMPRESSED_ISA(ENABLE_COMPRESSED),
        .ENABLE_COUNTERS(ENABLE_COUNTERS),
        .ENABLE_MUL(ENABLE_MUL),
        .ENABLE_DIV(ENABLE_DIV),
        .ENABLE_FAST_MUL(ENABLE_FAST_MUL),
        .ENABLE_IRQ(1),
        .ENABLE_IRQ_QREGS(ENABLE_IRQ_QREGS)
    ) cpu (
        .clk(clk),
        .resetn(resetn),
        .mem_valid(mem_valid),
        .mem_instr(mem_instr),
        .mem_ready(mem_ready),
        .mem_addr(mem_addr),
        .mem_wdata(mem_wdata),
        .mem_wstrb(mem_wstrb),
        .mem_rdata(mem_rdata)
    );

    memory #(
        .WORDS(MEM_WORDS)
    ) ram (
        .clk(clk),
        .wen((mem_valid &amp;&amp; mem_addr &lt; 4 * MEM_WORDS) ? mem_wstrb : 4&#39;b0),
        .addr(mem_addr[23:2]),
        .wdata(mem_wdata),
        .rdata(mem_rdata)
    );
endmodule
</code></pre>
<p>We will run this asm program to check IF cpu is working or not</p>
<pre><code class="language-asm">loop:
    nop
    nop
    c.j loop
</code></pre>
<p>This is the memory layout of this program</p>
<pre><code class="language-asm">Disassembly of section .text:

00000000 &lt;loop&gt;:
   0:	0001                	c.addi	zero,0
   2:	0001                	c.addi	zero,0
   4:	bff5                	c.j	0 &lt;loop&gt;
</code></pre>
<p>üì¶ Prepare Memory Contents
Create a memory.mem file which contains the hex representation of above asm program:</p>
<pre><code>00010001
0000bff5
</code></pre>
<p>Each line is a 32-bit instruction in hex .
This will help you verify the system is fetching and executing instructions.</p>
<p>üß™ Create a Testbench (top_tb.v)</p>
<pre><code class="language-verilog">`timescale 1ns / 1ps

module top_tb;

    reg clk;
    reg resetn;

    top uut (
        .clk(clk),
        .resetn(resetn)
    );

    initial clk = 0;
    always #5 clk = ~clk; // 100 MHz clock

    initial begin
        $display(&quot;Starting simulation...&quot;);
        #100;
        resetn = 0;
        #100;
        resetn = 1;

        $display(&quot;Reset deasserted. Running...&quot;);

        #10000;

        $display(&quot;Simulation finished.&quot;);
        $finish;
    end

endmodule
</code></pre>
<p>‚úÖ What to Expect
After you run the simulation:</p>
<p>Check the Program Counter (PC) inside the picorv32 instance.</p>
<p>If it increments over time, your system is booting and executing the loop. 0 -&gt; 2 -&gt; 4 
<img src="/media/reg_pc_sim.png" alt="vivado behav sim"></p>
<p>If it stays stuck, recheck clock, reset, or memory connections.
If everything is okay 
then Hurray You booted a minimal SOC which consists CPU and memory.</p>
<h2>üß™ <a id="step2"></a>Step 2: Connect the Peripherals</h2>
<p>Peripherals might seem magical at first, but they‚Äôre actually very straightforward‚Äîthey behave just like memory.</p>
<p>You assign each peripheral a memory address, and then your processor can read and write to that address just like normal RAM. This concept is called memory-mapped I/O.</p>
<p>In our system, we will:</p>
<p>Map LEDs to a specific address so we can control them.</p>
<p>Map a UART peripheral (for serial communication) to two memory-mapped registers.</p>
<h3>üìå Peripheral Memory Map</h3>
<pre><code>    Peripheral	Address Range
    RAM	0x0000_0000 ‚Äì 0x0000_1000
    LED Module	0x0200_0000
    UART (Baud)	0x0200_0004
    UART (Data)	0x0200_0008
</code></pre>
<p>UART has two registers:</p>
<p>Baud Rate Register: Sets how fast data is transmitted.</p>
<p>Data Register: Used for both sending and receiving characters.</p>
<p>When two UART devices use the same baud rate, they can talk to each other.</p>
<p>Take a look at the code that handles memory-mapped peripherals:</p>
<pre><code class="language-verilog">wire led_sel = mem_valid &amp;&amp; (mem_addr == 32&#39;h0200_0000);
wire simpleuart_reg_div_sel = mem_valid &amp;&amp; (mem_addr == 32&#39;h0200_0004);
wire simpleuart_reg_dat_sel = mem_valid &amp;&amp; (mem_addr == 32&#39;h0200_0008);
</code></pre>
<h3>üí° Implementing the LED Module</h3>
<p>The LED module behaves just like memory. Here‚Äôs a minimal implementation:</p>
<pre><code class="language-verilog">
module led_module (
    input clk,
    input resetn,
    input [3:0] wen,
    input [31:0] wdata,
    output reg [31:0] rdata
);
    (* syn_keep *) reg [31:0] device_reg;
    always @(posedge clk) begin
        if (!resetn) 
            device_reg &lt;= 32&#39;h0;
        else if (|wen) begin 
            if (wen[0]) device_reg[7:0]   &lt;= wdata[7:0];
            if (wen[1]) device_reg[15:8]  &lt;= wdata[15:8];
            if (wen[2]) device_reg[23:16] &lt;= wdata[23:16];
            if (wen[3]) device_reg[31:24] &lt;= wdata[31:24];
        end
    end
    

    always @(*) begin
        rdata = device_reg;
    end
endmodule
</code></pre>
<p>The lower 4 bits of device_reg will drive the LEDs. You can wire them directly to the FPGA output pins.</p>
<h3>‚úâÔ∏è Adding UART Support</h3>
<p>Add simpleuart.v from the picorv32/picosoc/ folder to your project.</p>
<h3>üèó Updated Top Module</h3>
<p>Here‚Äôs how your top-level SoC module should look after adding LED and UART peripherals.</p>
<pre><code class="language-verilog">`timescale 1ns / 1ns
module top #(
    parameter NO_OF_LEDS = 4
)
(
    input clk,
    input resetn,

    
	output ser_tx,
	input  ser_rx,
	
    output [NO_OF_LEDS-1:0] led,
    output reset_led
   
    
);  
    parameter MEM_WORDS = 8192;
    parameter [ 0:0] ENABLE_COUNTERS = 1;
    parameter [ 0:0] ENABLE_COUNTERS64 = 1;
    parameter [ 0:0] ENABLE_REGS_16_31 = 1;
    parameter [ 0:0] ENABLE_REGS_DUALPORT = 1;
    parameter [ 0:0] LATCHED_MEM_RDATA = 0; 
    parameter [ 0:0] TWO_STAGE_SHIFT = 0;
    parameter [ 0:0] BARREL_SHIFTER = 1;
    parameter [ 0:0] TWO_CYCLE_COMPARE = 0;
    parameter [ 0:0] TWO_CYCLE_ALU = 0;
    parameter [ 0:0] COMPRESSED_ISA = 1;
    parameter [ 0:0] CATCH_MISALIGN = 1;
    parameter [ 0:0] CATCH_ILLINSN = 1;
    parameter [ 0:0] ENABLE_PCPI = 0;
    parameter [ 0:0] ENABLE_MUL = 1;
    parameter [ 0:0] ENABLE_FAST_MUL = 0;
    parameter [ 0:0] ENABLE_DIV = 1;
    parameter [ 0:0] ENABLE_IRQ = 0;
    parameter [ 0:0] ENABLE_IRQ_QREGS = 0;
    parameter [ 0:0] ENABLE_IRQ_TIMER = 0;
    parameter [ 0:0] ENABLE_TRACE = 0;
    parameter [ 0:0] REGS_INIT_ZERO = 0;
    parameter [31:0] MASKED_IRQ = 32&#39;h 0000_0000;
    parameter [31:0] LATCHED_IRQ = 32&#39;h ffff_ffff;
    parameter [31:0] PROGADDR_RESET = 32&#39;h 0000_0000;
    parameter [31:0] PROGADDR_IRQ = 32&#39;h 0000_0000;
    parameter [31:0] STACKADDR = 32&#39;d 8000;
    
    wire mem_valid;
    wire mem_instr;
    wire mem_ready;
    wire [31:0] mem_addr;
    wire [31:0] mem_wdata;
    wire [3:0] mem_wstrb;
    wire [31:0] mem_rdata;
    
   
    // RAM signals
    reg ram_ready;
    wire [31:0] ram_rdata;
    
    // led Signals
    wire [31:0] led_rdata;
    
    
    wire led_sel = mem_valid &amp;&amp; (mem_addr == 32&#39;h 0200_0000);// adress of led module
    wire        simpleuart_reg_div_sel = mem_valid &amp;&amp; (mem_addr == 32&#39;h 0200_0004); // adress of uart baud reg
	wire [31:0] simpleuart_reg_div_do;

	wire        simpleuart_reg_dat_sel = mem_valid &amp;&amp; (mem_addr == 32&#39;h 0200_0008); // adress of uart I/O data
	wire [31:0] simpleuart_reg_dat_do;
	wire        simpleuart_reg_dat_wait;



 
    assign mem_ready = ram_ready || led_sel ||
			simpleuart_reg_div_sel || (simpleuart_reg_dat_sel &amp;&amp; !simpleuart_reg_dat_wait);

	assign mem_rdata =  ram_ready ? ram_rdata : simpleuart_reg_div_sel ? simpleuart_reg_div_do :
			simpleuart_reg_dat_sel ? simpleuart_reg_dat_do : led_sel ? led_rdata : 32&#39;h 0000_0000;

   
                   
    always @(posedge clk)
        ram_ready &lt;= mem_valid &amp;&amp; !mem_ready &amp;&amp; mem_addr &lt; 4*MEM_WORDS;
   
       picorv32 #(
        .ENABLE_COUNTERS(ENABLE_COUNTERS),
        .ENABLE_COUNTERS64(ENABLE_COUNTERS64),
        .ENABLE_REGS_16_31(ENABLE_REGS_16_31),
        .ENABLE_REGS_DUALPORT(ENABLE_REGS_DUALPORT),
        .LATCHED_MEM_RDATA(LATCHED_MEM_RDATA),
        .TWO_STAGE_SHIFT(TWO_STAGE_SHIFT),
        .BARREL_SHIFTER(BARREL_SHIFTER),
        .TWO_CYCLE_COMPARE(TWO_CYCLE_COMPARE),
        .TWO_CYCLE_ALU(TWO_CYCLE_ALU),
        .COMPRESSED_ISA(COMPRESSED_ISA),
        .CATCH_MISALIGN(CATCH_MISALIGN),
        .CATCH_ILLINSN(CATCH_ILLINSN),
        .ENABLE_PCPI(ENABLE_PCPI),
        .ENABLE_MUL(ENABLE_MUL),
        .ENABLE_FAST_MUL(ENABLE_FAST_MUL),
        .ENABLE_DIV(ENABLE_DIV),
        .ENABLE_IRQ(ENABLE_IRQ),
        .ENABLE_IRQ_QREGS(ENABLE_IRQ_QREGS),
        .ENABLE_IRQ_TIMER(ENABLE_IRQ_TIMER),
        .ENABLE_TRACE(ENABLE_TRACE),
        .REGS_INIT_ZERO(REGS_INIT_ZERO),
        .MASKED_IRQ(MASKED_IRQ),
        .LATCHED_IRQ(LATCHED_IRQ),
        .PROGADDR_RESET(PROGADDR_RESET),
        .PROGADDR_IRQ(PROGADDR_IRQ),
        .STACKADDR(STACKADDR)
    ) cpu (
        .clk(clk),
        .resetn(resetn),
        .mem_valid(mem_valid),
        .mem_instr(mem_instr),
        .mem_ready(mem_ready),
        .mem_addr(mem_addr),
        .mem_wdata(mem_wdata),
        .mem_rdata(mem_rdata),
        .mem_wstrb(mem_wstrb),
        
        .trap(),
        // Look-Ahead Interface (Unused)
        .mem_la_read(),        
        .mem_la_write(),       
        .mem_la_addr(),        
        .mem_la_wdata(),       
        .mem_la_wstrb(),       

        // Pico Co-Processor Interface (Unused)
        .pcpi_valid(),         
        .pcpi_insn(),          
        .pcpi_rs1(),          
        .pcpi_rs2(),          
        .pcpi_wr(),           
        .pcpi_rd(),           
        .pcpi_wait(),         
        .pcpi_ready(),        

        // IRQ Interface (Explicitly tied to 0)
        .irq(32&#39;b0),           
        .eoi(),           

        // Debug/Trace Interface (Unused)
        .trace_valid(),       
        .trace_data() 
    );

    simpleuart simpleuart (
		.clk         (clk         ),
		.resetn      (resetn      ),

		.ser_tx      (ser_tx      ),
		.ser_rx      (ser_rx      ),

		.reg_div_we  (simpleuart_reg_div_sel ? mem_wstrb : 4&#39;b 0000),
		.reg_div_di  (mem_wdata),
		.reg_div_do  (simpleuart_reg_div_do),

		.reg_dat_we  (simpleuart_reg_dat_sel ? mem_wstrb[0] : 1&#39;b 0),
		.reg_dat_re  (simpleuart_reg_dat_sel &amp;&amp; !mem_wstrb),
		.reg_dat_di  (mem_wdata),
		.reg_dat_do  (simpleuart_reg_dat_do),
		.reg_dat_wait(simpleuart_reg_dat_wait)
	);
	
    memory #(
        .WORDS(MEM_WORDS)
    ) ram (
        .clk(clk),
        .wen((mem_valid &amp;&amp; !mem_ready &amp;&amp; mem_addr &lt; 4*MEM_WORDS) ? mem_wstrb : 4&#39;b0),
        .addr(mem_addr[23:2]),
        .wdata(mem_wdata),
        .rdata(ram_rdata)
    );

    // LED device with simpler interface
    led_module device (
        .clk(clk),
        .resetn(resetn),
        .wen(led_sel ? mem_wstrb : 4&#39;b0),
        .wdata(mem_wdata),
        .rdata(led_rdata)
    );
    
    
    assign led = led_rdata[NO_OF_LEDS-1:0];
    assign reset_led = resetn;
endmodule


module led_module (
    input clk,
    input resetn,
    input [3:0] wen,
    input [31:0] wdata,
    output reg [31:0] rdata
);
    (* syn_keep *) reg [31:0] device_reg;
    always @(posedge clk) begin
        if (!resetn) 
            device_reg &lt;= 32&#39;h0;
        else if (|wen) begin 
            if (wen[0]) device_reg[7:0]   &lt;= wdata[7:0];
            if (wen[1]) device_reg[15:8]  &lt;= wdata[15:8];
            if (wen[2]) device_reg[23:16] &lt;= wdata[23:16];
            if (wen[3]) device_reg[31:24] &lt;= wdata[31:24];
        end
    end
    

    always @(*) begin
        rdata = device_reg;
    end
endmodule







</code></pre>
<p>Note: You can change the NO_OF_LEDS parameter to match your board. Also, wire the resetn signal to a physical button for hardware reset.</p>
<p>Now update the testbench also </p>
<pre><code class="language-verilog">`timescale 1ns / 1ns

module top_tb;
    // Simulation parameters
    parameter CLK_PERIOD = 20; // 
    parameter NO_OF_LEDS = 4;
   
    // Testbench signals
    reg clk;
    reg resetn;
    reg ser_rx;
    wire ser_tx;
    wire [NO_OF_LEDS-1:0] led;
    wire reset_led;
    
    // Instantiate the SOC with debug signals
    top #(
        .NO_OF_LEDS(NO_OF_LEDS)
    )uut (
        .clk(clk),
        .resetn(resetn),
        .ser_rx(ser_rx),
        .ser_tx(ser_tx),
        .led(led),
        .reset_led(reset_led)
    );

    // Clock generation
    initial begin
        clk = 0;
        forever #(CLK_PERIOD/2) clk = ~clk;
    end


    initial begin
        // Initialize signals
        #100;
        clk = 0;
        resetn = 0;
        ser_rx = 1;
        #100;   // Wait 100ns
        resetn = 1;  // Release reset

        // Run simulation for some time
        #1000;

        $finish;
    end

endmodule
</code></pre>
<h3>üí° Writing to the LEDs (RISC-V Assembly)</h3>
<pre><code class="language-asm">.section .text
.globl _start
_start:
    li t0, 0x02000000  # Base address of LED register
    li t1, 0           # Counter = 0

write_loop:
    sw t1, 0(t0)       # Write t1 to LED register
    addi t1, t1, 1     # t1 = t1 + 1
    li t2, 16          # Limit = 16
    blt t1, t2, write_loop

hang:
    j hang             # Done. Halt here
</code></pre>
<p>Disassembled layout:</p>
<pre><code class="language-asm">Disassembly of section .text:

00000000 &lt;_start&gt;:
   0:	020002b7          	lui	t0,0x2000
   4:	4301                	c.li	t1,0

00000006 &lt;write_loop&gt;:
   6:	0062a023          	sw	t1,0(t0) # 2000000 &lt;hang+0x1ffffee&gt;
   a:	0305                	c.addi	t1,1
   c:	43c1                	c.li	t2,16
   e:	fe734ce3          	blt	t1,t2,6 &lt;write_loop&gt;

00000012 &lt;hang&gt;:
  12:	a001                	c.j	12 &lt;hang&gt;
</code></pre>
<h3>üì¶ Memory File (memory.mem)</h3>
<p>Paste the following into your memory.mem:</p>
<pre><code>020002b7
a0234301
03050062
4ce343c1
a001fe73
</code></pre>
<h3>‚úÖ Simulation Output</h3>
<p>Once you run the simulation, the led output should cycle through values 0 to 15.
<img src="/media/led_sim.png" alt="vivado behav sim"></p>
<p>You‚Äôve now:</p>
<p>Mapped peripherals into memory</p>
<p>Controlled LEDs using RISC-V assembly</p>
<p>Set up UART communication</p>
<p>Built a fully working SoC with Verilog and assembly</p>
<p>All the source code used above is in this repo :  <a href="https://github.com/avinashlalotra/RTLtoHelloWorld">https://github.com/avinashlalotra/RTLtoHelloWorld</a></p>

      </article>
    </div>
  </div>
</body>
</html>