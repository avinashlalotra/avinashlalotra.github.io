
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Optimizing newlib routines</title>
<style>
  body {
    font-family: "Inter", system-ui, sans-serif;
    background-color: hsl(var(--background));
    color: hsl(var(--foreground));
    margin: 0;
    padding: 0;
    line-height: 1.7;
    transition: background-color 0.3s, color 0.3s;
  }

  article {
    max-width: 800px;
    margin: 2rem auto;
    padding: 2rem;
    background-color: hsl(var(--card));
    color: hsl(var(--card-foreground));
    border-radius: var(--radius);
    box-shadow: 0 2px 12px hsl(var(--border) / 0.3);
    transition: background-color 0.3s, color 0.3s, box-shadow 0.3s;
  }

  h1, h2, h3 {
    line-height: 1.3;
    font-weight: 600;
  }
  h1 { font-size: 2rem; margin-bottom: 0.5rem; }
  h2 {
    margin-top: 2rem;
    font-size: 1.5rem;
    border-bottom: 1px solid hsl(var(--border));
    padding-bottom: 0.3rem;
  }

  pre {
    background-color: hsl(var(--code-bg));
    color: hsl(var(--code-text));
    padding: 1rem 1.2rem;
    border-radius: 10px;
    overflow-x: auto;
    font-family: "Fira Code", monospace;
    font-size: 0.95rem;
    margin: 1.5rem 0;
    transition: background-color 0.3s, color 0.3s;
  }

  code {
    background-color: hsl(var(--code-bg));
    color: hsl(var(--code-text));
    padding: 0.2em 0.4em;
    border-radius: 4px;
    font-family: "Fira Code", monospace;
    font-size: 0.95em;
    transition: background-color 0.3s, color 0.3s;
  }

  pre code {
    background: none;
    padding: 0;
  }

  a {
    color: hsl(var(--primary));
    text-decoration: none;
    transition: color 0.3s;
  }

  a:hover {
    text-decoration: underline;
  }

  hr {
    border: none;
    border-top: 1px solid hsl(var(--border));
    margin: 2rem 0;
  }

  p, ul, ol {
    margin-bottom: 1rem;
  }

  ul {
    padding-left: 1.5rem;
  }

  i {
    color: hsl(var(--muted-foreground));
  }

  h1 code, h2 code, h3 code {
    background-color: hsl(var(--muted));
    color: hsl(var(--foreground));
    padding: 0.15em 0.3em;
    border-radius: 4px;
    font-size: 0.9em;
  }
</style>

<script>
  window.location.replace(window.location.origin + '/?redirect=' + window.location.pathname);
</script>




</head>
<body>
  <article>
    <h1>Optimizing newlib routines</h1>
    <p><i>2025-11-01 ‚Äî Abinash</i></p>
    <h1>üöÄ Optimizing <code>memset()</code> in RISC-V Assembly ‚Äî From C to Bare Metal</h1>
<h2>üå± Background: A Challenge Worth Writing About</h2>
<p>Earlier this year, I applied for the <strong>LFX Mentorship (RISC-V Newlib Optimization Summer 2025)</strong> program. The goal? To work on optimizing functions in <strong>newlib</strong>, the standard C library for embedded systems.</p>
<p>I didn‚Äôt make it to the final cohort ‚Äî but I <strong>did</strong> complete the screening task, which involved writing an <strong>optimized <code>memset()</code></strong> implementation using <strong>hand-written RISC-V assembly</strong>.</p>
<p>This blog walks through that journey:  </p>
<ul>
<li>Interfacing C with assembly  </li>
<li>Writing architecture-specific code  </li>
<li>Running it all on a bare-metal RISC-V environment using <code>spike</code></li>
</ul>
<hr>
<h2>üîç The Task: Rebuild <code>memset()</code> in Assembly</h2>
<p>The <code>memset()</code> function is a core part of libc ‚Äî it fills memory with a given byte value. A naive implementation in C might look like this:</p>
<pre><code class="language-c">void *memset(void *ptr, int x, size_t n) {
    unsigned char *p = ptr;
    while (n--) *p++ = (unsigned char)x;
    return ptr;
}
</code></pre>
<p>But writing this in <strong>assembly</strong>, you can make it <strong>smarter and faster</strong> ‚Äî especially by:</p>
<ul>
<li>Using 4-byte stores (<code>sw</code>) instead of byte-by-byte (<code>sb</code>)</li>
<li>Aligning pointers for word-sized writes</li>
<li>Minimizing loop instructions</li>
</ul>
<hr>
<h2>‚öôÔ∏è C ‚Üî Assembly Interface</h2>
<h3>Step 1: Declaring <code>memset()</code> in C</h3>
<p>In <code>memset.c</code>, I used the <code>extern</code> keyword to tell the C compiler that the function will be defined in assembly:</p>
<pre><code class="language-c">extern void *memset(void *ptr, int x, size_t n);
</code></pre>
<p>This allows me to call the function in C tests just like any other C function.</p>
<hr>
<h3>Step 2: Writing <code>memset()</code> in RISC-V Assembly</h3>
<p>Here‚Äôs the basic (unaligned) version I wrote:</p>
<pre><code class="language-asm">.section .text
.global memset
memset:                        # a0 = ptr, a1 = value, a2 = size
    mv t1, a0                  # t1 = pointer
    beqz a2, end               # if size == 0, return

    # Expand byte to 32-bit pattern
    slli t2, a1, 8
    or t2, t2, a1
    slli t3, t2, 16
    or t2, t2, t3              # now t2 = 0x01010101 if x = 0x01

    srli t3, a2, 2             # t3 = number of 4-byte chunks
    andi a2, a2, 3             # a2 = leftover bytes

word_loop:
    beqz t3, byte_loop
    sw t2, 0(t1)
    addi t1, t1, 4
    addi t3, t3, -1
    j word_loop

byte_loop:
    beqz a2, end
    sb a1, 0(t1)
    addi t1, t1, 1
    addi a2, a2, -1
    j byte_loop

end:
    ret
</code></pre>
<p>This version works well, but we can do better‚Ä¶</p>
<hr>
<h2>üß† Bonus Version: Aligned <code>memset()</code></h2>
<p>To maximize performance, I wrote an <strong>alignment-aware version</strong> that first aligns the pointer to a 4-byte boundary using <code>sb</code>, and then proceeds with <code>sw</code>.</p>
<pre><code class="language-asm">.align_loop:
    sb a1, 0(t1)
    addi t1, t1, 1
    addi a2, a2, -1
    andi t0, t1, 3
    bnez t0, align_loop
</code></pre>
<p>Once aligned, the optimized loop continues with <code>sw</code> instructions.</p>
<hr>
<h2>üß™ Testing with C</h2>
<p>I wrote a test suite in C to verify the correctness of my <code>memset()</code>:</p>
<pre><code class="language-c">void test_memset() {
    char buffer[10];
    memset(buffer, &#39;A&#39;, 10);

    char buffer2[50];
    memset(buffer2, &#39;B&#39;, 50);

    char buffer3[20];
    memset(buffer3, &#39;C&#39;, 0);  // edge case

    char buffer4[1000];
    memset(buffer4, &#39;D&#39;, 1000);
}
</code></pre>
<hr>
<h2>üîß Building and Running with Spike</h2>
<p>To run the program on a simulated RISC-V machine, I used the following script:</p>
<h3><code>run.sh</code></h3>
<pre><code class="language-bash">#!/bin/bash
filename=$1
testfile=$2

riscv64-unknown-elf-as -o memset.o $filename
riscv64-unknown-elf-gcc -o test.elf memset.o $testfile
spike pk test.elf
rm *.o 
</code></pre>
<h3>Run it:</h3>
<pre><code class="language-bash">chmod +x run.sh
./run.sh memset.S memset.c              # for basic version
./run.sh memset_aligned.S memset.c     # for aligned version
</code></pre>
<p>Make sure you have the following installed:</p>
<ul>
<li><code>riscv64-unknown-elf-gcc</code></li>
<li><code>spike</code> simulator</li>
<li><code>pk</code> (proxy kernel)</li>
</ul>
<hr>
<h2>üìä Results</h2>
<p>Both implementations passed all test cases. For large buffers (like 1000 bytes), the aligned version showed better performance and fewer instructions.</p>
<hr>
<h2>üí° Key Takeaways</h2>
<p>‚úÖ Learnings from this project:</p>
<ul>
<li>Cleanly interfacing C and assembly  </li>
<li>Understanding calling conventions (RISC-V ABI)  </li>
<li>Manual pointer alignment  </li>
<li>Using <code>spike</code> to simulate embedded behavior  </li>
<li>Gaining insight into how libc is implemented under the hood</li>
</ul>
<p>Even though this started as a screening task, it turned into a full learning experience in systems programming and optimization.</p>
<hr>
<h2>üìå Resources</h2>
<ul>
<li>üíª GitHub Repo: <a href="https://github.com/avinashlalotra/newlib-Optimization-Task">https://github.com/avinashlalotra/newlib-Optimization-Task</a>  </li>
<li>üìñ Newlib Source: <a href="https://sourceware.org/newlib/">https://sourceware.org/newlib/</a>  </li>
<li>üìö RISC-V ELF ABI Spec: <a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">https://github.com/riscv-non-isa/riscv-elf-psabi-doc</a>  </li>
<li>üõ† RISC-V GNU Toolchain: <a href="https://github.com/riscv-collab/riscv-gnu-toolchain">https://github.com/riscv-collab/riscv-gnu-toolchain</a></li>
</ul>
<hr>
<h2>üôè Final Thoughts</h2>
<p>I may not have gotten the mentorship, but I walked away with something just as valuable: confidence and clarity in writing system-level code.</p>
<p>If you&#39;re into embedded systems, toolchains, or want to break into open source ‚Äî I highly recommend trying small tasks like these. Feel free to fork the repo and experiment!</p>
<p><strong>Thanks for reading!</strong><br>‚Äî Abinash Singh
üìå GitHub: <a href="https://github.com/avinashlalotra/newlib-Optimization-Task">https://github.com/avinashlalotra/newlib-Optimization-Task</a> </p>

  </article>
</body>
</html>
  